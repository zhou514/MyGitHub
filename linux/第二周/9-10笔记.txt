#
echo "some text"
grep 'searchstring' file.txt 
expr 2 "+" 3 
cat file.txt
tail -n file.txt
head -n file.txt

特殊字符
#注释
; 命令分隔符
；； case 分支语句 结束
. 当前文件目录   	..上级目录
"string"
'char'
, 表达式的连接符
\ 反斜杠     转义符 \X
/ eg： cd /root/Desktop 目录分割
： 空命令
！     例如： !q
* 通配符   ls *.txt
?   ls  a?c.txt      a>b?c:d
$ 变量替换  num = 2 ;echo “this is $num”
( ) 命令组  ｛ ｝花括号存放代码块
| 管道    command1 | command2 | command3
      grep  file.txt | more

#!/bin/sh 
a="hello world" #对变量赋值
# “=” 两边不能出现空白
#bash 变量无类型
echo "A is:" # 现在打印变量a的内容
echo $a
num = 2
echo "this is ${num}nd"

#局部变量：只在代码块或某个函数里有效
#!/bin/bash
hello="var1"
echo $hello
function func1 {
	local hello="var2"
	echo $hello
	}
func1
echo $hello

#var1	var2	var1

环境变量


位置参数
命令行传递给脚本的参数  $0 $1 $2 $3 $4。。。
$0  脚本名称  $1第一个参数  $2 第二个参数
#!/bin/sh
echo "number of vars:"$#
echo "values of vars:"$*
echo "value of var1:"$1
echo "value of var2:"$2
echo "value of var3:"$3
echo "value of var4:"$4


退出和退出状态
exit n （状态码 0~255 十进制数）
#!/bin/bash
echo hello
echo $? 
lskdf 
echo $? 
echo
exit 113


流程语句
if then
关系运算符
if [条件测试]
常用整数比较方法
-eq 相等 if["$a" -eq "$b"]
-ne 不等
-gt 大于符号
-ge 大于等于符号
-lt  小于
-le 小于等于
> >= < <=

字符串比较
= 等于
== 等于
!= 不等于
< > 
-z 字符串为空 ""  字符串长度为0
-n 字符串不为空 " " 空格字符串

混合
-a 逻辑与 例如：num1和num2都为真 num1 -a num2
-o 逻辑或

文件操作
-e 文件存在 if [file.txt -e]
-f 普通文件（其他文件类型：目录文件或设备文件）
-s 文件大小不为0
-d 文件是一个目录
-b 文件是一个块设备（软盘，光驱）
-c 文件是字符设备（键盘，声卡，调制解调器等）
-p 文件是一个管道 
-h 符号链接
-S socket
-t 文件与一个终端设备相关
-r -w -x 可读可写可执行

[$a == z*]  #判断变量a是否是以z字母开头 模式匹配
[$a == "z*"] #字面匹配

if[ condition1]
 then
  if[ condition2]
   then
     do something
  fi
fi

程序语句
常用操作符
计算类：=  +  -  *  /  % **（求幂）
位运算符： << (每移一位 相当于乘以2)	>>
	 &   &=  |   |=       ~(取反)   ^异或 ^=
逻辑运算   &&   ||

#!/bin/bash
#最大公约数，使用 Euclid算法
#参数检测
ARGS=2
E_BADARGS=85
if [ $# -ne "$ARGS" ]
then
    echo "Usage: `basename $0` first-number second-number"
    exit $E_BADARGS
fi
gcd()
{
dividend=$1 #赋任意值
divisor=$2 #这里两个参数赋值大小没有关系，为什么?
remainder=1 
    #如果在循环中使用未初始化变量，在循环中第一个传递值会使他返回一个错误信息
    until [ "$remainder" -eq 0 ]
    do 
    let "remainder = $dividend % $divisor"
    dividend=$divisor
    divisor=$remainder
    done 
}
gcd $1 $2
echo
echo "GCD of $1 and $2 = $dividend"
echo
exit 0








